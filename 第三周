练习了动态规划，得到好得问题状态，更好得进行状态转移，
暴力求解时如何不重复计算。
计算机操作系统第四个视频：Peterson算法来让两个进程不会打架，具体是如果一个A进程想要对共享内存进行操作，先自己举起旗子上面写A，然后再在共享内存上面贴另一个进程B的标志，同理如果B进程要操作共享内存
也要先举起旗子B再在上面贴A，最终如果两个人一起举起，看上面贴的是谁并且这个人举起了棋子，那么就他先操作。
比如A举起，再贴B，然后B举起，贴A，那么A先操作，A操作完了，就会把旗子放下，B看到没有人举起，就B操作。
看似这个算法是对的，但要怎么证明，可以画状态机，每次选择两个线程的一个执行一步，然后穷举所有状态
自己画很麻烦，老师用了一个python代码，算出所有状态，然后弄到一个网页，最后用编程自动画出了所有状态
第五个视频（互斥）：如果可以让硬件帮下忙，就可以不用那么复杂的算法，两个原子指令：
1：可以让所有线程不动，让一个线程动，就不会打架，（不动只是不去动那个要动线程的共享内存，没必要所有内存都不能动）
2：可以瞬间交换两个内存的值
自旋锁：如果要操作一个共享空间，先弄一个钥匙，然后每个线程要去操作时，先用原子指令1，让所有人不能动，然后用2，用自己的一个东西去和钥匙的地址交换，如果交换得到钥匙，那么就可以去
操作共享内存，如果没有得到，那么就一直交换，一直等到别人操作完，把钥匙规划，你再去交换钥匙，然后再去操作内存。
自旋锁另一种方法：一个线程要操作时先对那个空间弄个标记，再在自己本地计算想要把这个空间变成什么样子，计算好后去看一下标记是否还在，如果不在说明有别的线程在操作这个空间，就重新去标记，
直到标记保留，就去操作这个空间
缺陷：多个CPU有缓存，那么让所有线程不动时，还要把缓存锁住，很麻烦
如果钥匙被一个线程拿了，其他所有想要这个钥匙的线程都得空转，很浪费
使用场景：临界区几乎不拥堵，就是几乎没有线程去抢钥匙
禁止轮流切换
互斥锁：让操作系统来管理钥匙
