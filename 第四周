第六节：线程同步：在某个时间点共同达到互相已知的状态。我的理解是：把一个任务分成好多步，每一步可以分成几个小任务，然后这些小任务给多个线程去做，同步就意味着这些小任务先后完成，
最终在某个时刻都完成了，相当与同时完成了这一步，这就是同步生产者消费者问题：生产者就是比如生产打印'('，然后消费着要消费着打印')',消费者要消费的前提是有（，所以如果）的没有与
（配对，就是错的，生产者还有生产能力，也就是嵌套深度，比如3，则还有（没有配对的数最多是3，然后这可以相当与一个队列，生产者可以向队列加东西，而消费者可以到里面拿东西，生产者如果
看到队列满了，则不能再生产，消费者则队列空了不能拿。如果去判断队列满了用自旋锁，就是满了不生产但是要持续的检查是否满了，等不满了就去生产，这样是非常浪费的，所以可以让生产者判断满
了的时候把他加入到睡眠的队列，然后当有消费者消费的时候再去唤醒，消费者空的时候同理，但是必须不能让同类相互唤醒，如果生产者唤醒了消费者1，消费者1就去消费，并且唤醒消费者2，如果
消费者1正好消费完了，那么到消费者2就出错了。信号量：就是那个嵌套深度，比如一个游泳馆要进去必须要有钥匙，信号量就是钥匙，本来进去是从管理员那里获得，出来要归还钥匙，但是信号量的机制
是如果有人游泳完了要出去，先看看有没有人要进来，有就直接给等的人（唤醒一个线程）。哲学家吃饭问题：每个人的两边有一把叉子，每个叉子都有两个人共用，每个人吃饭的时候举起两把叉子才可以，
如果用信号量，两边的信号量都是一，举起一把叉子减一，但是会出现死锁，如果所有人同时举起一边的叉子，再判断另一边，看到是不行的，所以所有人都有又放下。解决方法就是用最简单的，每个要吃，
一起举起两个叉子，然后让想举起时向服务员申请，服务员来管理是否让你举起，虽然一个服务员可能会很慢，但是实际问题可能不是那么多人会同时吃饭，也可以增加多个服务员。
第七节：真实世界的并发编程
讲了高性能计算机：任务分解，然后并行运行。数据中心：要从传输数据，而且可能会同一个时间很多任务，比如微信同一个时间很多人发信息，如果多线程就会又锁的问题，不断的判断锁浪费时间，
如果用协程，可能会又一个协程要花费很多时间，所以用一个线程加多个协程，如果一个协程花费时间多了，线程会去换另一个协程。人机交互，浏览器的并行编程。
继续练了蓝桥杯真题
写六级
数学建模培训
