第八节：应对和处理bug，先是防御性编程，就是用assert()这个函数，在运行到一个阶段，什么状态是不可能存在的可以用assert来检查，写assert的检查内容也是一种编程，表现了程序的状态。
第一个bug是死锁，如果一个锁被占用，然后中断程序想要这个锁，中断会不断申请，并且中断想退出就必须先得到这个锁，这样程序就一直在这个中断里面，另一个死锁就和前面哲学家吃饭的问题一样
这个哲学家吃饭问题的解决方法是可以让这些锁必须遵循一个锁的获得顺序，现在如果有几个线程去获得锁，总有一个线程会按照这个顺序先拿到所有锁，然后再全部释放，就不会每个线程都拿走对方要
的锁，而大家都在等待
如果不上锁不就没有死锁了吗，但会有数据竞争，就会有同一个时间两个线程竞争一个内存，这样这个内存最终的值就会变成两个线程竞争的结果，但这个结果不确定，就不能保证原子性，所以要用
互斥锁，
死锁的检查就是把所有锁上记录下来，在用一个程序把锁的顺序排出来，弄成一个图，可以用图论的知识，然后看有没有顺序的违反
还讲了一些动态分析工具，大概了解了一些，没听太懂
然后保护空间内存的方法就是把一些内存赋一个特殊值，比如在一个栈顶设置，如果这个值被改变，就说明栈溢出了
第九节：操作系统状态机模型：操作系统就是一个程序，来运行其他程序，那么这个操作系统程序怎么来的呢，操作系统是怎么运行的，就是硬件厂商会在电脑开机的时候设一个初始值，这个就是操作系统的
最开始的状态，然后软件人员在这个状态开始取指令设计，后面还没有看
